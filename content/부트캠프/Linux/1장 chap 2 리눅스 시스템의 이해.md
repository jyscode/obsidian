
### 리눅스 설치

CPU - 제조사를 잘 파악하여 설치(AMD, ARM), 비트 수 확인하여 설치(x86, x64)
RAM- 메모리의 용량을 잘알고 있어야 함

**HDD** - 초기에 사용하던 IDE와 SCSI, SATA등의 인터페이스 간 이름 차이 인지
- IDE 디스크 : /dev/hda, /dev/hdb ... (이름이 hd?로 작성됨)
- SCSI, SATA, USB, SSD : /dev/sda, /dev/sdb ... (이름이 sd?로 작성됨)

네트워크 인터페이스- ip주소, 넷마스크, 게이트웨이 주소, dns ip등을 알아야 한다.


#RAID
### RAID

`여러 개의 하드디스크가 있을 때 동일한 데이터를 다른 위치에 중복해서 저장하는 방법`
`에러를 체크하는 패리티나 에러를 검출하고 복구하는 ECC의 사용 등 구성 방법에 따라 여러가지 존재`

**RAID에서 사용하는 기술**

1. 스트라이핑(속도)
	연속된 데이터를 여러 개의 디스크에 라운드로빈 방식으로 기록하는 기술
	
2. 미러링(안정성)
	디스크에 에러가 발생 시 데이터의 손실을 막기 위해 추가적으로 하나 이상의 장치에 중복 저장


===***RAID의 종류***===


`RAID-0[2] - 최소 디스크 수 []`
스트라이핑 기술을 사용하여 빠른 입출력 속도를 제공, 디스크 중 하나라도 오류 발생시 복구 불가

`RAID-1[2]`
미러링 기술을 사용하여 두 개의 디스크에 데이터를 동일하게 기록
디스크 낭비 50% 

`RAID-2[2]`
디스크는 스트라이핑 기술을 사용하고 에러를 감지하고 수정하기 위해 ECC 사용

`RAID-3[3]`
스트라이핑 기술을 사용하고 패리티 정보를 저장하기 위해 별도의 하나의 디스크 사용

`RAID-4[3]`
블록 형태의 스트라이핑 기숳을 사용하여 구성

`RAID-5[3]`
패리티 정보를 이용하여 하나의 디스크가 고장이 발생해도 사용이 가능한 구성
**가용공간 N-1**

`RAID-6[4]`
RAID-5와 비슷하지만 디스크에 2차 패리티 구성을 포함
**가용공간 N-2**



---

**LVM** - 여러개의 하드 디스크를 논리적으로 병합, 분할이 가능하게 해주는 기술

물리적 볼륨 PV
- 실제 디스크에 분할한 파티션(/dev/sda)

볼륨 그룹 VG
- 물리적 볼륨이 모여서 생성하는 덩어리

논리적 볼륨 LV
- VG에서 사용자가 필요한 만큼 할당하여 만들어지는 공간

물리적 확장 PE
- PV에서 나누어 사용하는 일종의 블록(Block) 같은 영역을 말하는데, 보통 1PE가 4MB 정도씩 할당된다.


---

### 리눅스의 구조

부트매니저 - 부팅을 도와주는 역할, 여러 운영체제가 설치되어 있을 시 선택하여 부팅
부트로더 - 부트매니저 프로그램, 하드디스크의 맨 앞쪽인 MBR영역에 설치

리눅스의 대표적인 부트로더로는 LILO, GRUB가 있다.
Centos7, Rocky 8 -> GRUB2 사용


GRUB

a 키를 누르고 single 을 입력하여 싱글모드로 진입
e grub.conf에 등록된 부팅 목록의 모든 항목을 직접 편집할 수 있도록 해준다



**디렉터리의 개요**

파일을 보관하는 곳, 루트를 중심으로 하위 디렉터리에 다수의 디렉터리가 존재하는 트리 구조

```
/ : 최상위 디렉터리, 루트 디렉터리
/bin : 실행 파일들이 들어있다. 여러 명령어들이 들어있음
/boot : 시스템 부팅 시 필요한 파일이 들어간 디렉터리
/dev : 물리적인 장치 등을 파일화하여 관리
/etc : 시스템 환경 설정 파일
/home : 개인 사용자들이 사용하는 홈 디렉터리가 위치
/lib : 라이브러리가 저장
/mnt : mount시 포인터가 되는 디렉터리
/proc : 현재의 프로세스 상태 정보
/root : 루트의 홈 디렉터리
/tmp : 임시 저장 디렉터리, 모든 사용자 접근가능
/usr : 시스템 운영에 필요한 명령, 응용 프로그램 위치
```



---

**리눅스 부팅**

1. 하드웨어 인식 
2. 소프트웨어 구동
init 프로세스 발생, init은 /etc/init 디렉터리 안에 설정되어 있는 환경파일을 읽어 들여 동작


| 파일명                | 설명                                   |
| :----------------- | :----------------------------------- |
| /etc/inittab       | 부팅과 관련된 실행 레벨이 정의                    |
| /etc/init/rcS.conf | 시스템 초기화 관련된 내용                       |
| /etc/init/rc.conf  | 부팅 시 각 레벨별로 진행되는 내용이 설정된 파일          |
| /etc/rc.d/rc.local | 사용자가 부팅시에 필요한 서비스를 구동할 때 이 파일에 넣어 구동 |

실행레벨 - /etc/inittab

0 종료
1 단일 사용자 모드(root pw 복구, 시스템 점검)
2 네트워크 사용하지 않는 다중 사용자 모드
3 네트워크 지원하는 다중 사용자 모드
4 사용 X
5 X 윈도를 사용하는 다중 사용자 모드(GUI)
6 재부팅


**로그인**

| 파일명            | 내용                                     |
| :------------- | -------------------------------------- |
| /etc/issue     | 사용자가 로그인 할 때 login 메시지를 보여주기 전 출력되는 내용 |
| /etc/issue.net | telnet을 통한 네트워크 접속 시 출력 메시지            |
| /etc/motd      | 성공적으로 로그인되었을 때 보여주는 메시지                |

**시스템 종료**

`shutdown [옵션] 시간 [경고메시지]`

```
-r 재부팅
-h 종료
-c 예약된 셧다운 취소
-k 경고 메시지만 전송
```

```
ex)
shutdown -r now : 즉시재부팅
shutdonw -h +10 : 10분 뒤 종료
shutdown -h 23:59 : 오후 11 59에 종료하도록 예약
```

재부팅
`reboot`

시스템 종료
`halt`

시스템 종료 및 전원 OFF
`poweroff`

종료, 재부팅
`init 0 , init 6`

---

### 파일 시스템의 이해

운영체제가 파티션이나 디스크에 데이터를 저장하고, 읽고 , 쓰고, 찾기 위해 구성하는 일련의 체계
(파티션 -> 파일시스템 -> 마운트)


파일 시스템의 기능

1. 파일 생성, 수정, 삭제 제공
2. 파일을 사용하기 적합한 형태의 구조로 구성
3. 다른 사용자와의 파일을 공동으로 사용할 수 있는 적절한 제어 방법 제공
4. 백업, 복구 기능 준비
5. 정보의 암호화 및 복호화 기능 제공


리눅스의 파일 시스템

```
ext4 : 리눅스의 대표적인 저널링 파일시스템
XFS: 1993년 SGI에서 개발한 저널링 파일시스템, RHEL7의 기본 파일시스템
```

리눅스 파일 시스템의 구조

```
Filesystem : [boot block, super block, i-list, Directory blocks and data blocks]


boot block : 파일시스템으로부터 리눅스 커널을 적재시키기 위한 블록
super block : 파일 시스템에 전체적인 정보를 가지고 있음 - 매직 넘버
i-list : i-node 번호의 목록
Directory-blocks : i-node 와 파일명 저장
Data-block : 파일이 보관해야 할 정보 저장


magic number : 특정 파일 시스템임을 알리는 정보
- ext 파일시스템 : 0xEF53

```

**X 윈도**

플랫폼과 독자적으로 작동하는 그래픽 개발을 위해 만든 프로젝트
네트워크 프로토콜에 기반을 둔 그래픽 사용자 인터페이스 환경

클라이언트 / 서버 구조로 되어 있고, 서로간의 통신을 위해 X Protocol을 사용
원격의 호스트 간에도 응용 프로토콜을 주고받을 수 있다.

Xlib - C언어로 구현된 클라이언트 라이브러리 X 서버와 대화를 해주는 역할 - XCB로 업그레이드 됨

**디스플레이 매니저**

GNOME - GDN
KDE - KDM

startx - X 윈도를 실행시키는 스크립트


***데스크톱 환경(Desktop Environment)***

GUI 환경을 제공하기 위해 사용자에게 제공되는 인터페이스 스타일

|         | KDE                 | GNOME             |
| :------ | :------------------ | ----------------- |
| DM      | KDM                 | GDM               |
| WM      | KWM - Kwin          | metacity - mutter |
| 파일관리자   | konquerer - dolphin | nautilus          |
| X 라이브러리 | Qt                  | GTK+              |


원격지에서 X 클라이언트 이용

`xhost - X 서버에 접근할 수 있는 클라이언트를 지정하거나 해제 하는 방법(IP 기반 인증)`

```
xhost : 현재 설정된 접근 목록 출력
xhost + : 모든 클라이언트의 접근 허용
xhost - : 모든 클라이언트의 접근 차단
xhost + 192.168.12.22 : 192.168.12.22 의 접속 허가(+ 생략가능)

```
`DISPLAY - X 클라이언트 프로그램이 실행 될 떄 표시되는 창이 설정되어 있는 환경변수`


`xauth - 접근 허가 파일 관련 도구(사용자 기반 인증)`
서버에서 보낸 키값을 클라이언트에서 추가하여 설정



X 윈도 응용 프로그램

GIMP - 그림판
Totem - Movie Player
evince - 문서 뷰어 프로그램
LibreOffice - 무료 배포 오피스 프로그램


---

Shell -  커널과 사용자간의 다리 역할, 사용자로부터 명령을 받아 해석하고 프로그램 실행

현재는 bash 가 표준

주요 환경 변수

```
HOME 사용자의 홈디렉터리
PATH 실행 파일을 찾는 디렉터리 경로
LANG 기본으로 지원되는 언어
PWD 현재 작업 디렉터리
SHELL 사용자의 로그인 셸
USER 사용자의 이름
DISPLAY X 윈도에서 출력되는 창
PS1 프롬프트 변수
```

명령행 완성기능 - tab

HIstory 기능 - history 숫자

alias 기능 새로운 명령 지정
`alias ls='ls -al'` - 기존 명령어 변경
`alias aaa='ls -al'` - 새로운 명령어 생성

지속적으로 사용하려면 .bashrc에 지정해야 함

|| 논리적 OR - 앞의 명령이 성공이면 결과 출력, 실패 시 뒤 명령어 실행
&& 논리적 AND - 앞의 명령이 성공적이어야 뒤 명령어 실행


표준입력 0, 표준 출력 1 , 표준 에러 2



**리다이렉션**

```
> 프로세스의 출력 변경
>> 프로세스의 출력을 지정한 곳에 추가
< 프로세스의 입력을 표준 입력에서 다른 입력으로 변경
<< 기호 뒤에 지정한 문자열을 입력으로 받아 해당 문자열이 나오기 전까지를 표준 입력으로 삼음
```

파이프

명령어1 | 명령어2

명령어 1의 결과 값이 명령어2의 입력으로 실행


산술 연산

`expr 값 연산자 값`

`곱하기에 경우 *가 특수 문자이기에 \*로 사용해야 한다`

`$[값 연산자 값] 을 사용하여 계산할수도 있다`


Bash Shell 관련 파일 및 디렉터리

```
/etc/profile 시스템 전체에 적용되는 환경변수와 시작관련 프로그램 설정
/etc/bashrc alias와 함수 설정
~/.bash_profile 개인 사용자의 환경 설정, 시작 프로그램 설정
~/.bashrc 개인 사용자의 alias와 함수
```


Shell 에서의 특수 문자

```
. 현재 디렉터리
.. 상위 디렉터리
'' 안의 모든 문자나 특수문자들을 일반문자로 취급
"" $, `, \ 를 제외한 모든 문자 일반문자로 취급
# 주석
$ 뒤에 오는 문자열을 변수로 취급
\ 이스케이프 문자로
바로 다음에 오는 특수문자의 기능 제거
alias 앞에 설정시 alias 효과 제거
긴 명령행 입력시 행을 연장
```



### 프로세스

실행중인 프로그램을 프로세스라고 함, 실행 시 PID 가 할당되어 관리

리눅스는 부팅시 커널이 init 프로세스라는 최초의 프로세스 발생(PID 1)

Shell에서 명령을 실행 시 프로세스가 종료될 때 까지 기다려야 하는 프로세스를 포어그라운드 프로세스
눈에 보이지 않게 뒤에서 실행하면 백그라운드 프로세스라고 한다

백그라운드로 실행시키려면 명령어 끝에 &를 붙이면 된다

포어그라운드 프로세스 종료 Ctrl + C
포어그라운드 프로세스 대기 Ctrl + Z


**시그널**

프로세스가 다른 프로세스에게 메시지를 보낼 때 사용

2 - SIGINT 실행 중지(Ctrl + C)
9 - SIGKILL 무조건 종료, 프로세스 강제 종료
15 - SIGTERM 프로세스 정상 종료
19 - SIGSTOP 터미널에서 요청한 정지  시그널
20 - SIGTSTP - 프로세스 대기 시그널(Ctrl + Z)


**데몬**

주기적이고 지속적인 서비스 요청을 처리하기 위해 계속 실행되는 프로세스
서버 역할을 하는 프로그램들이 해당

standalone - 부팅시에 실행되어 계속 상주하는 방식
inet - 서비스 요청이 들어왔을 때 관련 프로세스를 실행시키고 후에 자동 종료

ntsysv - 커서를 사용하여 부팅중 자동으로 실행되는 서비스를 설정할 수 있는 유틸리티
chkconfig 실행 레벨에 따른 서비스의 on/off 설정



